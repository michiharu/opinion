---
slug: stateless-is-the-most-important
title: 状態 > 結合 > 複雑性 > コード量
authors: [michiharu]
tags: [dev, simple, kiss]
---

シンプルさについて語るときに僕の語ること、というテーマでいくつかの記事を書きました。

- UNIX哲学に学ぶシンプル
- Less is More
- **状態 > 結合 > 複雑性 > コード量**
- アプリケーションコードをシンプルに
- N対Nより1対1
- 共通化の条件

今回は３回目、シンプルとは反対の概念である複雑さの評価です。

## 状態 > 結合 > 複雑性 > コード量

こちらの記事の受け売りですが、激しく同意できる内容でした。

[状態、結合、複雑性、コード量の順に最適化する](https://ohbarye.hatenablog.jp/entry/2022/01/31/state-coupling-complexity-code)

リンク先は5〜6分で読める短い内容なので是非読んでみてください。

記事の内容をまとめると次の通りです。

> 
状態 (state)、結合 (coupling)、複雑性 (complexity)、コード量 (code) の順に
コードを最適化すべき
- コードがよりステートレスになるなら、結合を増やすこともいとわない
- 結合を減らすためには、コードをもっと複雑にすることもある
- コードの複雑さが軽減されるなら、コードをコピーする
- コードの重複排除をするのは状態・結合・複雑性を増さない時のみに限る

この記事を読む前に、これらに関連した次のような考え・理解を持っていました。

- SSOT(Single Source Of Truth)は大切（**状態**）
  - DBの正規化も同じ発想
  - Reduxは必ず1つの場所で管理された状態を参照する仕組みを提供
  - 状態を別々の場所で管理して同期させるような設計は、正しく実装するのがとても大変
    - フロントにおけるデータとDOMの同期処理がそれ
    - View = Function(Model) という関数の発想でデータ=>DOMという単一方向の流れによって
      SSOTを実現しているのがReact
- 1つのコードに2つ以上のコードが依存するような設計は慎重な判断が必要(**結合**)
  - ある関数が解決したい課題のレイヤーを整えるために下位レイヤーの課題を別の関数に任せるという場合は注意を払うべき結合だとは考えません
  - 下位レイヤーの関数に複数の処理を依存させている場合、
    しばしば処理の抽象化が不十分だと要件の変更などにより下位レイヤーの関数の内部の分岐追加などを検討する場合があります。
    このようなケースでは下位レイヤーの関数をコピーすべきです。別々の関数として扱うことでコードをシンプルにします。
- 同じ目的の修正が複数の場所で必要な場合は共通化が必要なサイン(**結合、コード量**)
  - 共通処理が担当するタスクが出来るだけ小さくなるように十分に注意して設計する必要がある

記事を読むまでこれらの考え方は関係性はを整理できておらず、「ケースバイケースで使い分ける」程度の認識でした。
今後はこれらの設計上の考慮事項についてより曖昧さを排除した判断が可能になると思います。

## まとめ

設計の方針が明確に言語化されることによってチームでの共有に役立ちそうです。
複雑さを解消するために考える機会は無数にあるので積極的に活用していこうと思います。
